"""Contains the constraints class"""

from itertools import chain
import numpy as np


class Constraints:
    """Class that automatically manages must links and cannot links,
    transitivity and chunklets.

    Attributes
    ----------
    cannot_link : list
        List of tuple-like, in which pairs of indices are linked.
    must_link : list
        List of tuple-like, in which pairs of indices are linked.
    chunklets : list of lists
        List of chunklets, in which each chunklet is a list of object indices.
    chunklet_dict : dict
        Dict of `object index =>: chunklet`.

    """
    @staticmethod
    def from_classes(number_of_examples, labels, seed=None):
        """Generates Constraints from class labels

        Parameters
        ----------
        number_of_examples : int
            Number of examples to pick from each class.
        labels : array_like
            A list of every example's class.
        seed : int, optional 
            A seed to use in initialization.

        Returns
        -------
        Constraints
            Constraints generated by those objects

        """
        constraints = Constraints()
        classes = np.unique(labels)
        last_picks = []
        if seed is not None:
            np.random.seed(seed)
        for c in classes:
            pick = np.random.choice(np.argwhere(labels == c).ravel(),
                                    number_of_examples, replace=False)
            for i in range(number_of_examples - 1):
                last = pick[i]
                constraints.add_must_link(pick[i], pick[i + 1])

            for x in last_picks:
                constraints.add_cannot_link(x, last)
            last_picks.append(last)
        return constraints

    def __init__(self):
        self.cannot_link = []
        self.must_link = []
        self.chunklets = None
        self.chunklet_dict = None

    def add_must_link(self, a, b):
        """Adds a must link constraint.

        Parameters
        ----------
        a : int
            Index to be added
        b : int
            Index to be added
        """
        if a > b:
            self.add_must_link(b, a)
            return
        if a == b or [a, b] in self.must_link:
            return

        self.must_link.append([a, b])
        self.chunklets = None
        self.chunklet_dict = None
        # self.transitive_must_link(a, b)

    def add_cannot_link(self, a, b):
        """Adds a cannot link constraint.

        Parameters
        ----------
        a : int
            Index to be added
        b : int
            Index to be added

        """

    def is_feasible(self, y):
        """Short summary.

        Parameters
        ----------
        y : array_like
            Predicted clusters for objects.

        Returns
        -------
        bool
            Whether that prediction breaks no constraints.

        """
        y = np.array(y)
        chunklets = self.get_chunklets()
        csize = len(chunklets)
        for c in chunklets:
            if len(set(y[c])) > 1:
                return False
        return all((y[chunklets[i]][0] - y[chunklets[j]][0]) != 0
                   for i in range(csize) for j in range(i + 1, csize))

    def _find_chunklet(self, chunklets, a):
        """Finds the chunklet of object a

        Parameters
        ----------
        chunklets : list of lists
            A chunklets list (like the one generated from `get_chunklets`).
        a : int
            Object's index.

        Returns
        -------
        int
            Chunklet's index.

        """
        lc = len(chunklets)
        for i in range(lc):
            if a in chunklets[i]:
                return i
        return None

    def get_chunklets(self):
        """Return the chunklets originated by this set of constraints.
        It caches the results, so calling it is not expensive.

        Returns
        -------
        list of lists
            List of chunklets, where each chunklet is a list of object indices.

        """
        if self.chunklets is None:
            self.chunklets = self.make_chunklets()
        return self.chunklets

    def make_chunklets(self):
        """Generates the chunklets originated by this set of constraints.

        Returns
        -------
        list of lists
            List of chunklets, where each chunklet is a list of object indices.

        """
        chunklets = []
        for obj_x, obj_y in self.must_link:
            chunklet_a = self._find_chunklet(chunklets, obj_x)
            chunklet_b = self._find_chunklet(chunklets, obj_y)

            # neither are in chunklets
            if chunklet_a is None and chunklet_b is None:
                # add new chunklet
                chunklets.append([obj_x, obj_y])
            elif chunklet_a == chunklet_b:
                # nothing to do here, already fine
                continue
            elif chunklet_a is None:
                # add obj_x to obj_y's chunklet
                chunklets[chunklet_b].append(obj_x)
            elif chunklet_b is None:
                # add obj_x to obj_y's chunklet
                chunklets[chunklet_a].append(obj_y)
            else:
                # both have chunklets that should be joined
                new_chunklet = chunklets[chunklet_a] + chunklets[chunklet_b]
                if chunklet_a > chunklet_b:
                    # make sure that chunklet_b > chunklet_a
                    chunklet_a, chunklet_b = chunklet_b, chunklet_a
                del chunklets[chunklet_b]
                del chunklets[chunklet_a]
                chunklets.append(new_chunklet)
        return chunklets

    def get_flat_chunklets(self):
        return list(chain(*self.get_chunklets()))

    def get_chunklet_dict(self):
        """Return the chunklet dict originated by this set of constraints.
        It caches the results, so calling it is not expensive.

        Returns
        -------
        dict
            Dict of `object index =>: chunklet`.

        """
        if self.chunklet_dict is None:
            self.chunklet_dict = self.make_chunklet_dict()
        return self.chunklet_dict

    def make_chunklet_dict(self):
        """Return the chunklets dict originated by this set of constraints.

        Returns
        -------
        dict
            Dict of `object index =>: chunklet`.
        """
        chunklets = self.get_chunklets()
        chunk_dict = {}
        flattened = self.get_flat_chunklets()
        for idx in flattened:
            chunk_dict[idx] = self._find_chunklet(chunklets, idx)
        return chunk_dict

    def is_a_constraint(self, a, b):
        if a > b:
            return self.is_a_constraint(b, a)
        return [a, b] in self.cannot_link or [a, b] in self.must_link
